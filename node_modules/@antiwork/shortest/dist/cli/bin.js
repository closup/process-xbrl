#!/usr/bin/env node

// src/core/runner/index.ts
import { glob } from "glob";
import { resolve as resolve2 } from "path";

// src/core/compiler/index.ts
import { build } from "esbuild";
import { join, resolve } from "path";
import { mkdirSync, existsSync, writeFileSync } from "fs";
import { tmpdir } from "os";
var TestCompiler = class {
  cacheDir;
  defaultOptions = {
    format: "esm",
    platform: "node",
    target: "node18",
    sourcemap: true,
    bundle: true,
    external: [
      "shortest",
      "fs",
      "path",
      "os",
      "util",
      "events",
      "stream",
      "assert",
      "url",
      "crypto",
      "buffer",
      "querystring",
      "fsevents"
    ],
    banner: {
      js: `
        import { fileURLToPath } from 'url';
        import { dirname } from 'path';
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = dirname(__filename);
        import { createRequire } from "module";
        const require = createRequire(import.meta.url);
      `
    }
  };
  constructor() {
    this.cacheDir = join(tmpdir(), "shortest-cache");
    if (!existsSync(this.cacheDir)) {
      mkdirSync(this.cacheDir, { recursive: true });
    }
  }
  async compileFile(filePath) {
    const fileName = filePath.split("/").pop().replace(".ts", ".mjs");
    const outputPath = join(this.cacheDir, fileName);
    const packageJson = {
      type: "module",
      imports: {
        "shortest": resolve(process.cwd(), "packages/shortest/src/index.ts")
      }
    };
    writeFileSync(join(this.cacheDir, "package.json"), JSON.stringify(packageJson));
    await build({
      ...this.defaultOptions,
      entryPoints: [filePath],
      outfile: outputPath,
      alias: {
        shortest: resolve(process.cwd(), "packages/shortest/src/index.ts")
      },
      resolveExtensions: [".ts", ".js", ".mjs"],
      banner: {
        js: 'import { createRequire } from "module";const require = createRequire(import.meta.url);'
      }
    });
    return outputPath;
  }
  async loadModule(filePath, cwd) {
    const absolutePath = resolve(cwd, filePath);
    if (!existsSync(absolutePath)) {
      throw new Error(`Config file not found: ${filePath}`);
    }
    try {
      const result = await build({
        ...this.defaultOptions,
        entryPoints: [absolutePath],
        write: false,
        external: ["shortest"]
      });
      const code = result.outputFiles[0].text;
      const tempFile = join(this.cacheDir, "config.mjs");
      writeFileSync(tempFile, code);
      return import(`file://${tempFile}`);
    } catch (error) {
      throw new Error(`Failed to load config from ${absolutePath}: ${error}`);
    }
  }
};

// src/browser/manager/index.ts
import { chromium } from "playwright";
import { URL } from "url";
var BrowserManager = class {
  browser = null;
  context = null;
  config;
  constructor(config) {
    this.config = config;
  }
  normalizeUrl(url) {
    try {
      const parsedUrl = new URL(url);
      return parsedUrl.toString();
    } catch {
      return url;
    }
  }
  async launch() {
    this.browser = await chromium.launch({
      headless: this.config.headless ?? false
    });
    this.context = await this.browser.newContext({
      viewport: { width: 1920, height: 1080 }
    });
    const page = await this.context.newPage();
    await page.goto(this.normalizeUrl(this.config.baseUrl));
    await page.waitForLoadState("networkidle");
    return this.context;
  }
  async clearContext() {
    if (!this.context) {
      throw new Error("No context available");
    }
    await Promise.all([
      this.context.clearCookies(),
      // Clear storage
      this.context.pages().map(
        (page) => page.evaluate(() => {
          localStorage.clear();
          sessionStorage.clear();
          indexedDB.deleteDatabase("shortest");
        })
      ),
      // Clear permissions
      this.context.clearPermissions()
    ]);
    await Promise.all(
      this.context.pages().map(
        (page) => page.goto("about:blank")
      )
    );
    const pages = this.context.pages();
    if (pages.length > 1) {
      await Promise.all(
        pages.slice(1).map((page) => page.close())
      );
    }
    const baseUrl = this.config.baseUrl;
    await pages[0].goto(baseUrl);
    await pages[0].waitForLoadState("networkidle");
    return this.context;
  }
  async recreateContext() {
    return this.clearContext();
  }
  async closeContext() {
    if (this.context) {
      await this.context.close();
      this.context = null;
    }
  }
  async close() {
    await this.closeContext();
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }
  getContext() {
    return this.context;
  }
};

// src/browser/core/index.ts
var ToolError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ToolError";
  }
};
var BaseBrowserTool = class {
  width;
  height;
  displayNum;
  screenshotDelay;
  toolType = "computer_20241022";
  toolName = "computer";
  constructor(options) {
    this.width = options.width;
    this.height = options.height;
    this.displayNum = options.displayNum || 1;
    this.screenshotDelay = options.screenshotDelay || 2e3;
  }
  validateCoordinates(x, y) {
    if (x < 0 || x > this.width || y < 0 || y > this.height) {
      throw new ToolError(`Coordinates (${x}, ${y}) out of bounds`);
    }
  }
  formatToolResult(output, error, base64_image, metadata) {
    return {
      output,
      error,
      base64_image,
      metadata
    };
  }
};

// src/browser/core/browser-tool.ts
import { writeFileSync as writeFileSync2, mkdirSync as mkdirSync2, readdirSync, statSync, unlinkSync } from "fs";
import { join as join2 } from "path";

// src/browser/integrations/github.ts
import { authenticator } from "otplib";
import dotenv from "dotenv";
var GitHubTool = class {
  totpSecret;
  selectors = {
    loginForm: "#login form",
    usernameInput: "#login_field",
    passwordInput: "#password",
    submitButton: '[type="submit"]',
    useAuthenticatorButton: 'button:has-text("Use authenticator")',
    useAuthenticatorLink: '[data-test-selector="totp-app-link"]',
    otpInput: "#app_totp",
    errorMessage: ".flash-error"
  };
  constructor(secret) {
    dotenv.config({ path: ".env.local" });
    dotenv.config({ path: ".env" });
    this.totpSecret = secret || process.env.GITHUB_TOTP_SECRET || "";
    if (!this.totpSecret) {
      throw new Error("GITHUB_TOTP_SECRET is required in .env file or via --secret flag");
    }
  }
  validateSecret() {
    if (!this.totpSecret) {
      throw new Error("GITHUB_TOTP_SECRET is required in .env file or via --secret flag");
    }
  }
  generateTOTPCode() {
    this.validateSecret();
    try {
      const code = authenticator.generate(this.totpSecret);
      const timeRemaining = authenticator.timeRemaining();
      return { code, timeRemaining };
    } catch (error) {
      throw new Error(`Failed to generate TOTP code: ${error}`);
    }
  }
  async GithubLogin(browserTool, credentials) {
    try {
      await browserTool.waitForSelector(this.selectors.loginForm, { timeout: 1e4 });
      await browserTool.fill(this.selectors.usernameInput, credentials.username);
      await browserTool.fill(this.selectors.passwordInput, credentials.password);
      await browserTool.click(this.selectors.submitButton);
      try {
        await browserTool.waitForSelector(this.selectors.useAuthenticatorButton, { timeout: 5e3 });
        await browserTool.click(this.selectors.useAuthenticatorButton);
      } catch {
        await browserTool.waitForSelector(this.selectors.useAuthenticatorLink, { timeout: 5e3 });
        await browserTool.click(this.selectors.useAuthenticatorLink);
      }
      await browserTool.waitForSelector(this.selectors.otpInput, { timeout: 1e3 });
      const { code } = this.generateTOTPCode();
      await browserTool.fill(this.selectors.otpInput, code);
      const navigationPromise = browserTool.waitForNavigation({ timeout: 3e3 });
      await browserTool.press(this.selectors.otpInput, "Enter");
      await navigationPromise;
      const currentUrl = await browserTool.getPage().url();
      const isLoggedIn = await browserTool.findElement(this.selectors.loginForm) === null;
      return {
        success: isLoggedIn,
        error: isLoggedIn ? void 0 : "Failed to verify login success"
      };
    } catch (error) {
      try {
        const currentUrl = await browserTool.getPage().url();
        if (!currentUrl.includes("github.com")) {
          return {
            success: true
          };
        }
      } catch {
      }
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error during GitHub login"
      };
    }
  }
};

// src/browser/actions/index.ts
var keyboardShortcuts = {
  "ctrl+l": ["Control", "l"],
  "ctrl+a": ["Control", "a"],
  "ctrl+c": ["Control", "c"],
  "ctrl+v": ["Control", "v"],
  "alt+tab": ["Alt", "Tab"],
  "return": ["Enter"],
  "enter": ["Enter"],
  "esc": ["Escape"],
  "tab": ["Tab"],
  "delete": ["Delete"],
  "backspace": ["Backspace"],
  "space": [" "],
  "arrowup": ["ArrowUp"],
  "arrowdown": ["ArrowDown"],
  "arrowleft": ["ArrowLeft"],
  "arrowright": ["ArrowRight"]
};
var scaleRatio = {
  x: 1543 / 1170,
  // ≈ 1.318
  y: 32 / 24
  // ≈ 1.333
};
async function mouseMove(page, x, y) {
  if (!Number.isInteger(x) || !Number.isInteger(y) || x < 0 || y < 0) {
    throw new ToolError("Coordinates must be non-negative integers");
  }
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await page.mouse.move(scaledX, scaledY);
  await page.waitForTimeout(100);
}
async function click(page, x, y) {
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await mouseMove(page, x, y);
  await page.mouse.click(scaledX, scaledY);
  await showClickAnimation(page);
}
async function dragMouse(page, x, y) {
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await page.mouse.down();
  await page.mouse.move(scaledX, scaledY);
  await page.mouse.up();
}
async function showClickAnimation(page) {
  try {
    await page.evaluate(() => {
      const cursor = document.getElementById("ai-cursor");
      if (cursor) {
        cursor.style.transform = "translate(-50%, -50%) scale(0.8)";
        setTimeout(() => {
          cursor.style.transform = "translate(-50%, -50%) scale(1)";
        }, 100);
      }
    });
  } catch (error) {
  }
}
async function getCursorPosition(page) {
  const position = await page.evaluate(() => {
    return window.cursorPosition || { x: 0, y: 0 };
  });
  return [position.x, position.y];
}

// src/browser/core/browser-tool.ts
import pc from "picocolors";

// src/types/test.ts
var CallbackError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CallbackError";
  }
};
var AssertionCallbackError = class extends CallbackError {
  constructor(message, actual, expected) {
    super(message);
    this.actual = actual;
    this.expected = expected;
    this.name = "AssertionCallbackError";
  }
};

// src/browser/core/browser-tool.ts
var BrowserTool = class extends BaseBrowserTool {
  page;
  browserManager;
  toolType = "computer_20241022";
  toolName = "computer";
  screenshotDir;
  cursorVisible = true;
  lastMousePosition = [0, 0];
  githubTool;
  viewport;
  testContext;
  MAX_SCREENSHOTS = 10;
  MAX_AGE_HOURS = 5;
  constructor(page, browserManager, config) {
    super(config);
    this.page = page;
    this.browserManager = browserManager;
    this.screenshotDir = join2(process.cwd(), ".shortest", "screenshots");
    mkdirSync2(this.screenshotDir, { recursive: true });
    this.viewport = { width: config.width, height: config.height };
    this.testContext = config.testContext;
    this.initialize();
    this.cleanupScreenshots();
  }
  async initialize() {
    this.page.on("load", async () => {
      try {
        await new Promise((resolve3) => setTimeout(resolve3, 1e3));
        await this.page.evaluate(() => {
          if (!document.getElementById("ai-cursor")) {
            const cursor = document.createElement("div");
            cursor.id = "ai-cursor";
            cursor.style.cssText = `
              width: 20px;
              height: 20px;
              border: 2px solid red;
              border-radius: 50%;
              position: fixed;
              pointer-events: none;
              z-index: 999999;
              transition: all 0.1s ease;
              transform: translate(-50%, -50%);
              background-color: rgba(255, 0, 0, 0.2);
            `;
            document.body.appendChild(cursor);
            window.cursorPosition = { x: 0, y: 0 };
            document.addEventListener("mousemove", (e) => {
              window.cursorPosition = { x: e.clientX, y: e.clientY };
              cursor.style.left = e.clientX + "px";
              cursor.style.top = e.clientY + "px";
            });
          }
        }).catch(() => {
        });
      } catch (error) {
      }
    });
  }
  async click(selector) {
    await this.page.click(selector);
  }
  async clickAtCoordinates(x, y) {
    await click(this.page, x, y);
  }
  async execute(input) {
    try {
      let output = "";
      let metadata = {};
      switch (input.action) {
        case "left_click":
        case "right_click":
        case "middle_click":
        case "double_click": {
          const clickCoords = input.coordinates || this.lastMousePosition;
          await this.clickAtCoordinates(clickCoords[0], clickCoords[1]);
          output = `${input.action} at (${clickCoords[0]}, ${clickCoords[1]})`;
          metadata = await this.getMetadata();
          await this.page.waitForTimeout(100);
          if (await this.page.evaluate(() => document.readyState !== "complete").catch(() => true)) {
            try {
              await this.page.waitForLoadState("domcontentloaded", { timeout: 5e3 });
              metadata = await this.getMetadata();
            } catch {
            }
          }
          break;
        }
        case "mouse_move":
          const coords = input.coordinates || input.coordinate;
          if (!coords) {
            throw new ToolError("Coordinates required for mouse_move");
          }
          await mouseMove(this.page, coords[0], coords[1]);
          this.lastMousePosition = [coords[0], coords[1]];
          output = `Mouse moved to (${coords[0]}, ${coords[1]})`;
          break;
        case "left_click_drag":
          if (!input.coordinates) {
            throw new ToolError("Coordinates required for left_click_drag");
          }
          await dragMouse(this.page, input.coordinates[0], input.coordinates[1]);
          output = `Dragged mouse to (${input.coordinates[0]}, ${input.coordinates[1]})`;
          break;
        case "cursor_position":
          const position = await getCursorPosition(this.page);
          output = `Cursor position: (${position[0]}, ${position[1]})`;
          break;
        case "screenshot":
          return await this.takeScreenshotWithMetadata();
        case "type":
          if (!input.text) {
            throw new ToolError("Text required for type action");
          }
          await this.page.waitForTimeout(100);
          await this.page.keyboard.type(input.text);
          await this.page.waitForTimeout(100);
          output = `Typed: ${input.text}`;
          break;
        case "key": {
          if (!input.text) {
            throw new ToolError("Key required for key action");
          }
          await this.page.waitForTimeout(100);
          const keyText = input.text.toLowerCase();
          const keys = Array.isArray(keyboardShortcuts[keyText]) ? keyboardShortcuts[keyText] : [keyboardShortcuts[keyText] || input.text];
          if (Array.isArray(keys)) {
            for (const key of keys) {
              await this.page.keyboard.down(key);
            }
            for (const key of [...keys].reverse()) {
              await this.page.keyboard.up(key);
            }
          } else {
            await this.page.keyboard.press(keys);
          }
          await this.page.waitForTimeout(100);
          output = `Pressed key: ${input.text}`;
          break;
        }
        case "github_login": {
          if (!this.githubTool) {
            this.githubTool = new GitHubTool();
          }
          const loginResult = await this.githubTool.GithubLogin(this, {
            username: input.username,
            password: input.password
          });
          output = loginResult.success ? "GitHub login was successfully completed" : `GitHub login failed: ${loginResult.error}`;
          break;
        }
        case "clear_session":
          const newContext = await this.browserManager.recreateContext();
          this.page = newContext.pages()[0] || await newContext.newPage();
          await this.page.evaluate(() => {
            localStorage.clear();
            sessionStorage.clear();
          });
          return {
            output: "Successfully cleared browser data and created new context",
            metadata: {}
          };
        case "run_callback": {
          if (!this.testContext?.currentTest) {
            throw new ToolError("No test context available for callback execution");
          }
          const testContext = this.testContext;
          const currentTest = testContext.currentTest;
          const currentStepIndex = testContext.currentStepIndex ?? 0;
          try {
            if (currentStepIndex === 0) {
              if (currentTest.fn) {
                await currentTest.fn({ page: this.page });
                testContext.currentStepIndex = 1;
                return {
                  output: "Test function executed successfully"
                };
              }
              return {
                output: "Skipping callback execution: No callback function defined for this test"
              };
            } else {
              const expectationIndex = currentStepIndex - 1;
              const expectation = currentTest.expectations?.[expectationIndex];
              if (expectation?.fn) {
                await expectation.fn({ page: this.page });
                testContext.currentStepIndex = currentStepIndex + 1;
                return {
                  output: `Callback function for "${expectation.description}" passed successfully`
                };
              } else {
                return {
                  output: `Skipping callback execution: No callback function defined for expectation "${expectation?.description}"`
                };
              }
            }
          } catch (error) {
            if (error && error.matcherResult) {
              const assertionError = error;
              throw new AssertionCallbackError(
                assertionError.message,
                assertionError.matcherResult.actual,
                assertionError.matcherResult.expected
              );
            }
            throw new CallbackError(error instanceof Error ? error.message : String(error));
          }
        }
        case "navigate": {
          if (!input.url) {
            throw new ToolError("URL required for navigation");
          }
          const newPage = await this.page.context().newPage();
          try {
            const navigationTimeout = 3e4;
            await newPage.goto(input.url, {
              timeout: navigationTimeout,
              waitUntil: "domcontentloaded"
            });
            await newPage.waitForLoadState("load", {
              timeout: 5e3
            }).catch((e) => {
              console.log("\u26A0\uFE0F Load timeout, continuing anyway");
            });
            this.page = newPage;
            output = `Navigated to ${input.url}`;
            metadata = {
              window_info: {
                url: input.url,
                title: await newPage.title(),
                size: this.page.viewportSize() || { width: this.width, height: this.height }
              }
            };
            break;
          } catch (error) {
            await newPage.close();
            throw new ToolError(`Navigation failed: ${error}`);
          }
        }
        default:
          throw new ToolError(`Unknown action: ${input.action}`);
      }
      try {
        await this.page.waitForTimeout(200);
        metadata = await this.getMetadata();
      } catch (metadataError) {
        console.warn("Failed to get metadata:", metadataError);
        metadata = {};
      }
      return {
        output,
        metadata
      };
    } catch (error) {
      console.error(pc.red("\n\u274C Browser Action Failed:"), error);
      if (error instanceof AssertionCallbackError) {
        return {
          output: `Assertion failed: ${error.message}${error.actual !== void 0 ? `
Expected: ${error.expected}
Received: ${error.actual}` : ""}`
        };
      }
      if (error instanceof CallbackError) {
        return {
          output: `Callback execution failed: ${error.message}`
        };
      }
      throw new ToolError(`Action failed: ${error}`);
    }
  }
  async getMetadata() {
    const metadata = {
      window_info: {},
      cursor_info: { position: [0, 0], visible: true }
    };
    try {
      let url;
      let title;
      try {
        url = await this.page.url();
      } catch {
        url = "navigating...";
      }
      try {
        title = await this.page.title();
      } catch {
        title = "loading...";
      }
      metadata.window_info = {
        url,
        title,
        size: this.page.viewportSize() || { width: this.width, height: this.height }
      };
      if (await this.isPageStable()) {
        const position = await getCursorPosition(this.page);
        metadata.cursor_info = {
          position,
          visible: this.cursorVisible
        };
      }
      return metadata;
    } catch (error) {
      return metadata;
    }
  }
  async isPageStable() {
    try {
      return await this.page.evaluate(() => {
        return document.readyState === "complete" && !document.querySelector(".loading") && !document.querySelector(".cl-loading");
      }).catch(() => false);
    } catch {
      return false;
    }
  }
  async takeScreenshotWithMetadata() {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const filePath = join2(this.screenshotDir, `screenshot-${timestamp}.png`);
    const buffer = await this.page.screenshot({
      type: "jpeg",
      quality: 50,
      scale: "device",
      fullPage: false
    });
    writeFileSync2(filePath, buffer);
    console.log(`Screenshot saved to: ${filePath}`);
    return {
      output: "Screenshot taken",
      base64_image: buffer.toString("base64"),
      metadata: await this.getMetadata()
    };
  }
  toToolParameters() {
    return {
      type: this.toolType,
      name: this.toolName,
      display_width_px: this.width,
      display_height_px: this.height,
      display_number: this.displayNum
    };
  }
  // Selector-based methods
  async waitForSelector(selector, options) {
    await this.page.waitForSelector(selector, options);
  }
  async fill(selector, value) {
    await this.page.fill(selector, value);
  }
  async press(selector, key) {
    await this.page.press(selector, key);
  }
  async findElement(selector) {
    return this.page.$(selector);
  }
  getPage() {
    return this.page;
  }
  async waitForNavigation(options) {
    await this.page.waitForLoadState("load", { timeout: options?.timeout });
  }
  updateTestContext(newContext) {
    this.testContext = newContext;
  }
  cleanupScreenshots() {
    try {
      const files = readdirSync(this.screenshotDir).filter((file) => file.endsWith(".png") || file.endsWith(".jpg")).map((file) => ({
        name: file,
        path: join2(this.screenshotDir, file),
        time: statSync(join2(this.screenshotDir, file)).mtime.getTime()
      })).sort((a, b) => b.time - a.time);
      const now = Date.now();
      const fiveHoursMs = this.MAX_AGE_HOURS * 60 * 60 * 1e3;
      files.forEach((file, index) => {
        const isOld = now - file.time > fiveHoursMs;
        const isBeyondLimit = index >= this.MAX_SCREENSHOTS;
        if (isOld || isBeyondLimit) {
          try {
            unlinkSync(file.path);
          } catch (error) {
            console.warn(`Failed to delete screenshot: ${file.path}`);
          }
        }
      });
    } catch (error) {
      console.warn("Failed to cleanup screenshots:", error);
    }
  }
};

// src/ai/client.ts
import Anthropic from "@anthropic-ai/sdk";

// src/ai/prompts/index.ts
var SYSTEM_PROMPT = `
You are a test automation expert with access to Chrome browser. When you are given a test case, 
you will need to execute the browser actions to validate the test cases. 
You are already in Chrome browser in the web page of the application in test case instructions, 
so you don't need to load the browser yourself.

This is an example of a test case that you might recieve: 

Test: "Login to the app using Github login"
Context: {"username":"argo.mohrad@gmail.com","password":"password1234"}
Callback function:  [NO_CALLBACK] 

Expect:
 1. Test case to be generated within at least 20 seconds [HAS_CALLBACK]

IMPORTANT RULES THAT YOU MUST ALWAYS FOLLOW WHEN EXECUTING TEST CASES:

1. Sometimes you may be instructed to wait for a certain condition to be met before you can continue with the next step.
That condition might be time in seconds, or minutes. Or it can be for a certain element to be visible, 
or a certain element to be clickable. Make sure you wait for the condition to be met before you continue with the next step. If the
condition is not met after the specified time, you should fail the test case.

2. You might need to use tools api to do some actions. If that's the case, wait until the 
tool has finished its execution before you continue with the next action. Once the tool 
has finished its execution, you will recieve the result of the tool execution wether it failed or not. You can decide 
to continue based on the result. Sometimes you might not understand the result of the tool based on screenshots, therefore you will
always recieve metadata about the tool execution which will help you understand the result.

3. IMPORTANT! DO NOT ask for screenshot until the tool has finished its execution. Once the tool has finished its execution,
you will recieve the result of the tool execution wether it failed or not.
Then you can ask for a screenshot to determine for your next action if anything else is needed.

4. If you need to test a login flow with Github 2fa, you need to call the "github_login" tool only after you have 
seen the github login page. If you call the tool before, it will not work as expected.

5.IMPORTANT! There is a feature provided to you by tools api called "run_callback" that allows you to run callback functions for a test step.
Whenever you see [HAS_CALLBACK] after the step description, you must call "run_callback" tool. Remember, only 
call "run_callback" tool after you have completed the browser actions for that step otherwise the callback will not work as expected.
When done, you can continue with the next step. If result of the callback is failed, you must fail the test case.

6. IMPORTANT! ONLY USE THIS TOOL IF YOU ARE SPECIFIED TO NAVIGATE TO A NEW PAGE IN THE TEST CASE INSTRUCTIONS. 
DO NOT USE THIS TOOL BASED ON YOUR INTUITION! If you need to navigate to a new page, you must use the "navigate" tool. 
Although you are already in a browser, you do not have access to the browser search bar, therefore, 
you must use the "navigate" tool to navigate to the new page. After navigating to the new page is done, 
you will recieve the result of the navigation and you can see if the the requested page is loaded or not from the 
url field in the metadata.

7. IMPORTANT! If there is a "Expect" present in the test intruction, you must make sure it is fulfilled. If not, you must fail the test case.

MUST FOLLOW THIS RULE: perform exactly as instructed in the test case instructions.

Your task is to:
1. Execute browser actions to validate test cases
2. Use provided browser tools to interact with the page
3. You must return the result of test execution in strict JSON format: { result: "pass" | "fail", reason: string }. 
for the failure reason, provide a maximum of 1 sentence.
4. For any click actions, you will need to provide the x,y coordinates of the element to click.
`;

// src/ai/tools/index.ts
var AITools = [
  {
    type: "computer_20241022",
    name: "computer",
    display_width_px: 1920,
    display_height_px: 1080,
    display_number: 1
  },
  {
    name: "github_login",
    description: "Handle GitHub OAuth login with 2FA",
    input_schema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["github_login"],
          description: "The action to perform. It's always equal to 'github_login'"
        },
        username: {
          type: "string",
          description: "GitHub username or email"
        },
        password: {
          type: "string",
          description: "GitHub password"
        }
      },
      required: ["action", "username", "password"]
    }
  },
  {
    name: "run_callback",
    description: "Run callback function for current test step",
    input_schema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["run_callback"],
          description: "Execute callback for current step"
        }
      },
      required: ["action"]
    }
  },
  {
    name: "navigate",
    description: "Navigate to URLs in new browser tabs",
    input_schema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["navigate"],
          description: "The action to perform"
        },
        url: {
          type: "string",
          description: "The URL to navigate to"
        }
      },
      required: ["action", "url"]
    }
  }
];

// src/ai/client.ts
import pc2 from "picocolors";
var AIClient = class {
  client;
  model;
  maxMessages;
  debugMode;
  constructor(config, debugMode = false) {
    if (!config.apiKey) {
      throw new Error("Anthropic API key is required. Set it in shortest.config.ts or ANTHROPIC_API_KEY env var");
    }
    this.client = new Anthropic({
      apiKey: config.apiKey
    });
    this.model = "claude-3-5-sonnet-20241022";
    this.maxMessages = 10;
    this.debugMode = debugMode;
  }
  async processAction(prompt, browserTool, outputCallback, toolOutputCallback) {
    const maxRetries = 3;
    let attempts = 0;
    while (attempts < maxRetries) {
      try {
        return await this.makeRequest(prompt, browserTool, outputCallback, toolOutputCallback);
      } catch (error) {
        attempts++;
        if (attempts === maxRetries)
          throw error;
        console.log(`Retry attempt ${attempts}/${maxRetries}`);
        await new Promise((r) => setTimeout(r, 5e3 * attempts));
      }
    }
  }
  async makeRequest(prompt, browserTool, outputCallback, toolOutputCallback) {
    const messages = [];
    if (this.debugMode) {
      console.log(pc2.cyan("\n\u{1F916} Prompt:"), pc2.dim(prompt));
    }
    messages.push({
      role: "user",
      content: prompt
    });
    while (true) {
      try {
        await new Promise((resolve3) => setTimeout(resolve3, 1e3));
        const response = await this.client.beta.messages.create({
          model: this.model,
          max_tokens: 1024,
          messages,
          system: SYSTEM_PROMPT,
          tools: [...AITools],
          betas: ["computer-use-2024-10-22"]
        });
        if (this.debugMode) {
          response.content.forEach((block) => {
            if (block.type === "text") {
              console.log(pc2.green("\n\u{1F916} AI:"), pc2.dim(block.text));
            } else if (block.type === "tool_use") {
              const toolBlock = block;
              console.log(pc2.yellow("\n\u{1F527} Tool Request:"), {
                tool: toolBlock.name,
                input: toolBlock.input
              });
            }
          });
        }
        messages.push({
          role: "assistant",
          content: response.content
        });
        if (response.stop_reason === "tool_use") {
          const toolResults = response.content.filter((block) => block.type === "tool_use").map((block) => {
            const toolBlock = block;
            return {
              toolBlock,
              result: browserTool.execute(toolBlock.input)
            };
          });
          const results = await Promise.all(toolResults.map((t) => t.result));
          if (this.debugMode) {
            results.forEach((result, i) => {
              const { base64_image, ...logResult } = result;
              console.log(pc2.blue("\n\u{1F527} Tool Result:"), logResult);
            });
          }
          messages.push({
            role: "user",
            content: results.map((result, index) => ({
              type: "tool_result",
              tool_use_id: toolResults[index].toolBlock.id,
              content: result.base64_image ? [{
                type: "image",
                source: {
                  type: "base64",
                  media_type: "image/jpeg",
                  data: result.base64_image
                }
              }] : [{
                type: "text",
                text: result.output || ""
              }]
            }))
          });
        } else {
          return {
            messages,
            finalResponse: response
          };
        }
      } catch (error) {
        if (error.message?.includes("rate_limit")) {
          console.log("\u23F3 Rate limited, waiting 60s...");
          await new Promise((resolve3) => setTimeout(resolve3, 6e4));
          continue;
        }
        throw error;
      }
    }
  }
};

// src/index.ts
import dotenv2 from "dotenv";
import { join as join3 } from "path";
import { expect as jestExpect } from "expect";
var globalConfig = null;
var compiler = new TestCompiler();
if (!global.__shortest__) {
  global.__shortest__ = {
    expect: jestExpect,
    registry: {
      tests: /* @__PURE__ */ new Map(),
      currentFileTests: [],
      beforeAllFns: [],
      afterAllFns: [],
      beforeEachFns: [],
      afterEachFns: []
    }
  };
  global.expect = global.__shortest__.expect;
  dotenv2.config({ path: join3(process.cwd(), ".env") });
  dotenv2.config({ path: join3(process.cwd(), ".env.local") });
}
function validateConfig(config) {
  const missingFields = [];
  if (config.headless === void 0)
    missingFields.push("headless");
  if (!config.baseUrl)
    missingFields.push("baseUrl");
  if (!config.testDir)
    missingFields.push("testDir");
  if (!config.anthropicKey && !process.env.ANTHROPIC_API_KEY)
    missingFields.push("anthropicKey");
  if (missingFields.length > 0) {
    throw new Error(
      `Missing required fields in shortest.config.ts:
` + missingFields.map((field) => `  - ${field}`).join("\n")
    );
  }
}
async function initialize() {
  if (globalConfig)
    return globalConfig;
  dotenv2.config({ path: join3(process.cwd(), ".env") });
  dotenv2.config({ path: join3(process.cwd(), ".env.local") });
  const configFiles = [
    "shortest.config.ts",
    "shortest.config.js",
    "shortest.config.mjs"
  ];
  for (const file of configFiles) {
    try {
      const module = await compiler.loadModule(file, process.cwd());
      if (module.default) {
        const config = module.default;
        validateConfig(config);
        globalConfig = {
          ...config,
          anthropicKey: process.env.ANTHROPIC_API_KEY || config.anthropicKey
        };
        return globalConfig;
      }
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Config Error: ${error.message}`);
      }
      continue;
    }
  }
  throw new Error(
    "No config file found. Create shortest.config.ts in your project root.\nRequired fields:\n  - headless: boolean\n  - baseUrl: string\n  - testDir: string | string[]\n  - anthropicKey: string"
  );
}
function getConfig() {
  if (!globalConfig) {
    throw new Error("Config not initialized. Call initialize() first");
  }
  return globalConfig;
}
function createTestChain(name, payload, fn) {
  const test2 = {
    name,
    payload,
    fn,
    expectations: []
  };
  global.__shortest__.registry.tests.set(
    name,
    [...global.__shortest__.registry.tests.get(name) || [], test2]
  );
  global.__shortest__.registry.currentFileTests.push(test2);
  const chain = {
    expect(description, payloadOrFn, fn2) {
      test2.expectations = test2.expectations || [];
      if (typeof payloadOrFn === "function") {
        fn2 = payloadOrFn;
        payloadOrFn = void 0;
      }
      test2.expectations.push({
        description,
        payload: payloadOrFn,
        fn: fn2
      });
      return chain;
    }
  };
  return chain;
}
var test = Object.assign(
  (name, payload, fn) => createTestChain(name, payload, fn),
  {
    beforeAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeAllFns.push(hook);
    },
    afterAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterAllFns.push(hook);
    },
    beforeEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeEachFns.push(hook);
    },
    afterEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterEachFns.push(hook);
    }
  }
);

// src/utils/logger.ts
import pc3 from "picocolors";
var Logger = class {
  currentFile = "";
  testResults = [];
  startTime = Date.now();
  startFile(file) {
    this.currentFile = file.split("/").pop() || file;
    console.log(pc3.blue(`
\u{1F4C4} ${pc3.bold(this.currentFile)}`));
  }
  reportTest(name, status = "passed", error) {
    const icon = this.getStatusIcon(status);
    console.log(`    ${icon} ${name}`);
    if (status === "failed" && error?.message) {
      console.log(pc3.red(`        Reason: ${error.message}`));
    }
    this.testResults.push({ name, status, error });
  }
  getStatusIcon(status) {
    switch (status) {
      case "pending":
        return pc3.yellow("\u25CB");
      case "running":
        return pc3.blue("\u25CF");
      case "passed":
        return pc3.green("\u2713");
      case "failed":
        return pc3.red("\u2717");
    }
  }
  summary() {
    const duration = ((Date.now() - this.startTime) / 1e3).toFixed(2);
    const totalTests = this.testResults.length;
    const failedTests = this.testResults.filter((t) => t.status === "failed").length;
    const passedTests = totalTests - failedTests;
    console.log(pc3.dim("\u23AF".repeat(50)));
    console.log(
      pc3.bold("\n Tests "),
      failedTests ? pc3.red(`${failedTests} failed`) : "",
      failedTests && passedTests ? " | " : "",
      pc3.green(`${passedTests} passed`),
      pc3.dim(`(${totalTests})`)
    );
    console.log(pc3.bold(" Duration  "), pc3.dim(`${duration}s`));
    console.log(pc3.bold(" Start at  "), pc3.dim(new Date(this.startTime).toLocaleTimeString()));
    console.log(pc3.dim("\n" + "\u23AF".repeat(50)));
  }
  allTestsPassed() {
    return !this.testResults.some((test2) => test2.status === "failed");
  }
  reportStatus(message) {
    console.log(pc3.blue(`
${message}`));
  }
  error(context, message) {
    console.error(pc3.red(`
${context} Error: ${message}`));
  }
  reportError(context, message) {
    console.error(pc3.red(`
${context} Error: ${message}`));
  }
  reportAssertion(step, status, error) {
    const icon = status === "passed" ? "\u2713" : "\u2717";
    const color = status === "passed" ? "green" : "red";
    console.log(pc3[color](`${icon} ${step}`));
    if (error && status === "failed") {
      console.log(pc3.red(`  Expected: ${error.matcherResult?.expected}`));
      console.log(pc3.red(`  Received: ${error.matcherResult?.actual}`));
      console.log(pc3.red(`  Message: ${error.message}`));
    }
  }
};

// src/core/runner/index.ts
var TestRunner = class {
  config;
  cwd;
  exitOnSuccess;
  forceHeadless;
  targetUrl;
  compiler;
  browserManager;
  logger;
  debugAI;
  constructor(cwd, exitOnSuccess = true, forceHeadless = false, targetUrl, debugAI = false) {
    this.cwd = cwd;
    this.exitOnSuccess = exitOnSuccess;
    this.forceHeadless = forceHeadless;
    this.targetUrl = targetUrl;
    this.debugAI = debugAI;
    this.compiler = new TestCompiler();
    this.logger = new Logger();
  }
  async initialize() {
    await initialize();
    this.config = getConfig();
    if (this.forceHeadless) {
      this.config = {
        ...this.config,
        headless: true
      };
    }
    if (this.targetUrl) {
      this.config = {
        ...this.config,
        baseUrl: this.targetUrl
      };
    }
    this.browserManager = new BrowserManager(this.config);
  }
  async findTestFiles(pattern) {
    const testDirs = Array.isArray(this.config.testDir) ? this.config.testDir : [this.config.testDir || "__tests__"];
    const files = [];
    for (const dir of testDirs) {
      if (pattern) {
        const cleanPattern = pattern.replace(/\.ts$/, "").replace(/\.test$/, "").split("/").pop();
        const globPattern = `${dir}/**/${cleanPattern}.test.ts`;
        const matches = await glob(globPattern, {
          cwd: this.cwd,
          absolute: true
        });
        files.push(...matches);
      } else {
        const globPattern = `${dir}/**/*.test.ts`;
        const matches = await glob(globPattern, { cwd: this.cwd });
        files.push(...matches.map((f) => resolve2(this.cwd, f)));
      }
    }
    if (files.length === 0) {
      this.logger.error("Test Discovery", `No test files found in directories: ${testDirs.join(", ")}`);
      process.exit(1);
    }
    return files;
  }
  async executeTest(test2, context) {
    const page = context.pages()[0];
    const browserTool = new BrowserTool(page, this.browserManager, {
      width: 1920,
      height: 1080,
      testContext: {
        page,
        currentTest: test2,
        currentStepIndex: 0
      }
    });
    const aiClient = new AIClient({
      apiKey: this.config.anthropicKey,
      model: "claude-3-5-sonnet-20241022",
      maxMessages: 10,
      debug: this.debugAI
    }, this.debugAI);
    try {
      const initialState = await browserTool.execute({
        action: "screenshot"
      });
      const prompt = [
        `Test: "${test2.name}"`,
        test2.payload ? `Context: ${JSON.stringify(test2.payload)}` : "",
        `Callback function: ${test2.fn ? " [HAS_CALLBACK]" : " [NO_CALLBACK]"}`,
        // Add expectations if they exist
        ...test2.expectations?.length ? [
          "\nExpect:",
          ...test2.expectations.map(
            (exp, i) => `${i + 1}. ${exp.description}${exp.fn ? " [HAS_CALLBACK]" : "[NO_CALLBACK]"}`
          )
        ] : [],
        "\nCurrent Page State:",
        `URL: ${initialState.metadata?.window_info?.url || "unknown"}`,
        `Title: ${initialState.metadata?.window_info?.title || "unknown"}`
      ].filter(Boolean).join("\n");
      const result = await aiClient.processAction(prompt, browserTool, (content) => {
        if (content.type === "text") {
        }
      });
      if (!result) {
        throw new Error("AI processing failed: no result returned");
      }
      const finalMessage = result.finalResponse.content.find(
        (block) => block.type === "text" && block.text.includes('"result":')
      );
      if (finalMessage && finalMessage.type === "text") {
        const jsonMatch = finalMessage.text.match(/{[\s\S]*}/);
        if (jsonMatch) {
          const testResult = JSON.parse(jsonMatch[0]);
          return testResult;
        }
      }
      throw new Error("No test result found in AI response");
    } catch (error) {
      return {
        result: "fail",
        reason: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async executeTestFile(file) {
    try {
      const registry = global.__shortest__.registry;
      registry.tests.clear();
      registry.currentFileTests = [];
      this.logger.startFile(file);
      const compiledPath = await this.compiler.compileFile(file);
      await import(compiledPath);
      const context = await this.browserManager.launch();
      const testContext = { page: context.pages()[0] };
      try {
        for (const hook of registry.beforeAllFns) {
          await hook(testContext);
        }
        for (const test2 of registry.currentFileTests) {
          for (const hook of registry.beforeEachFns) {
            await hook(testContext);
          }
          const result = await this.executeTest(test2, context);
          this.logger.reportTest(
            test2.name,
            result.result === "pass" ? "passed" : "failed",
            result.result === "fail" ? new Error(result.reason) : void 0
          );
          for (const hook of registry.afterEachFns) {
            await hook(testContext);
          }
        }
        for (const hook of registry.afterAllFns) {
          await hook(testContext);
        }
      } finally {
        await this.browserManager.close();
        registry.beforeAllFns = [];
        registry.afterAllFns = [];
        registry.beforeEachFns = [];
        registry.afterEachFns = [];
      }
    } catch (error) {
      if (error instanceof Error) {
        this.logger.reportError("Test Execution", error.message);
      }
    }
  }
  async runFile(pattern) {
    await this.initialize();
    const files = await this.findTestFiles(pattern);
    if (files.length === 0) {
      this.logger.error("Test Discovery", `No test files found matching: ${pattern}`);
      process.exit(1);
    }
    for (const file of files) {
      await this.executeTestFile(file);
    }
    this.logger.summary();
    if (this.exitOnSuccess && this.logger.allTestsPassed()) {
      process.exit(0);
    } else {
      process.exit(1);
    }
  }
  async runAll() {
    await this.initialize();
    const files = await this.findTestFiles();
    for (const file of files) {
      await this.executeTestFile(file);
    }
    this.logger.summary();
    if (this.exitOnSuccess && this.logger.allTestsPassed()) {
      process.exit(0);
    } else {
      process.exit(1);
    }
  }
};

// src/cli/bin.ts
import pc4 from "picocolors";
process.removeAllListeners("warning");
process.on("warning", (warning) => {
  if (warning.name === "DeprecationWarning" && warning.message.includes("punycode")) {
    return;
  }
  console.warn(warning);
});
var VALID_FLAGS = ["--headless", "--github-code", "--debug-ai", "--help", "-h"];
var VALID_PARAMS = ["--target", "--secret"];
function showHelp() {
  console.log(`
${pc4.bold("Shortest")} - AI-powered end-to-end testing framework
${pc4.dim("https://github.com/anti-work/shortest")}

${pc4.bold("Usage:")}
  shortest [options] [test-pattern]

${pc4.bold("Options:")}
  --headless          Run tests in headless browser mode
  --debug-ai          Show AI conversation and decision process
  --target=<url>      Set target URL for tests (default: http://localhost:3000)
  --github-code       Generate GitHub 2FA code for authentication

${pc4.bold("Authentication:")}
  --secret=<key>      GitHub TOTP secret key (or use .env.local)

${pc4.bold("Examples:")}
  ${pc4.dim("# Run all tests")}
  shortest

  ${pc4.dim("# Run specific test file")}
  shortest login.test.ts

  ${pc4.dim("# Run tests in headless mode")}
  shortest --headless

  ${pc4.dim("# Generate GitHub 2FA code")}
  shortest --github-code --secret=<OTP_SECRET>

${pc4.bold("Environment Setup:")}
  Required variables in .env.local:
  - ANTHROPIC_API_KEY     Required for AI test execution
  - GITHUB_TOTP_SECRET    Required for GitHub authentication
  - GITHUB_USERNAME       GitHub login credentials
  - GITHUB_PASSWORD       GitHub login credentials

${pc4.bold("Documentation:")}
  Visit ${pc4.cyan("https://github.com/anti-work/shortest")} for detailed setup and usage
`);
}
async function handleGitHubCode(args) {
  try {
    const secret = args.find((arg) => arg.startsWith("--secret="))?.split("=")[1];
    const github = new GitHubTool(secret);
    const { code, timeRemaining } = github.generateTOTPCode();
    console.log("\n" + pc4.bgCyan(pc4.black(" GitHub 2FA Code ")));
    console.log(pc4.cyan("Code: ") + pc4.bold(code));
    console.log(pc4.cyan("Expires in: ") + pc4.bold(`${timeRemaining}s`));
    console.log(pc4.dim(`Using secret from: ${secret ? "CLI flag" : ".env file"}
`));
    process.exit(0);
  } catch (error) {
    console.error(pc4.red("\n\u2716 Error:"), error.message, "\n");
    process.exit(1);
  }
}
function isValidArg(arg) {
  if (VALID_FLAGS.includes(arg)) {
    return true;
  }
  const paramName = arg.split("=")[0];
  if (VALID_PARAMS.includes(paramName)) {
    return true;
  }
  return false;
}
async function main() {
  const args = process.argv.slice(2);
  if (args.includes("--help") || args.includes("-h")) {
    showHelp();
    process.exit(0);
  }
  if (args.includes("--github-code")) {
    await handleGitHubCode(args);
  }
  const invalidFlags = args.filter((arg) => arg.startsWith("--")).filter((arg) => !isValidArg(arg));
  if (invalidFlags.length > 0) {
    console.error(`Error: Invalid argument(s): ${invalidFlags.join(", ")}`);
    process.exit(1);
  }
  const headless = args.includes("--headless");
  const targetUrl = args.find((arg) => arg.startsWith("--target="))?.split("=")[1];
  const testPattern = args.find((arg) => !arg.startsWith("--"));
  const debugAI = args.includes("--debug-ai");
  try {
    const runner = new TestRunner(process.cwd(), true, headless, targetUrl, debugAI);
    await runner.initialize();
    if (testPattern) {
      await runner.runFile(testPattern);
    } else {
      await runner.runAll();
    }
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.includes("Config")) {
        console.error(pc4.red("\nConfiguration Error:"));
        console.error(pc4.dim(error.message));
        console.error(pc4.dim("\nMake sure you have a valid shortest.config.ts with all required fields:"));
        console.error(pc4.dim("  - headless: boolean"));
        console.error(pc4.dim("  - baseUrl: string"));
        console.error(pc4.dim("  - testDir: string | string[]"));
        console.error(pc4.dim("  - anthropicKey: string"));
        console.error();
      } else {
        console.error(pc4.red("\nError:"), error.message);
      }
    } else {
      console.error(pc4.red("\nUnknown error occurred"));
    }
    process.exit(1);
  }
}
main().catch((error) => {
  console.error(error);
  process.exit(1);
});
