// src/index.ts
import dotenv from "dotenv";
import { join as join2 } from "path";
import { expect as jestExpect } from "expect";

// src/core/compiler/index.ts
import { build } from "esbuild";
import { join, resolve } from "path";
import { mkdirSync, existsSync, writeFileSync } from "fs";
import { tmpdir } from "os";
var TestCompiler = class {
  cacheDir;
  defaultOptions = {
    format: "esm",
    platform: "node",
    target: "node18",
    sourcemap: true,
    bundle: true,
    external: [
      "shortest",
      "fs",
      "path",
      "os",
      "util",
      "events",
      "stream",
      "assert",
      "url",
      "crypto",
      "buffer",
      "querystring",
      "fsevents"
    ],
    banner: {
      js: `
        import { fileURLToPath } from 'url';
        import { dirname } from 'path';
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = dirname(__filename);
        import { createRequire } from "module";
        const require = createRequire(import.meta.url);
      `
    }
  };
  constructor() {
    this.cacheDir = join(tmpdir(), "shortest-cache");
    if (!existsSync(this.cacheDir)) {
      mkdirSync(this.cacheDir, { recursive: true });
    }
  }
  async compileFile(filePath) {
    const fileName = filePath.split("/").pop().replace(".ts", ".mjs");
    const outputPath = join(this.cacheDir, fileName);
    const packageJson = {
      type: "module",
      imports: {
        "shortest": resolve(process.cwd(), "packages/shortest/src/index.ts")
      }
    };
    writeFileSync(join(this.cacheDir, "package.json"), JSON.stringify(packageJson));
    await build({
      ...this.defaultOptions,
      entryPoints: [filePath],
      outfile: outputPath,
      alias: {
        shortest: resolve(process.cwd(), "packages/shortest/src/index.ts")
      },
      resolveExtensions: [".ts", ".js", ".mjs"],
      banner: {
        js: 'import { createRequire } from "module";const require = createRequire(import.meta.url);'
      }
    });
    return outputPath;
  }
  async loadModule(filePath, cwd) {
    const absolutePath = resolve(cwd, filePath);
    if (!existsSync(absolutePath)) {
      throw new Error(`Config file not found: ${filePath}`);
    }
    try {
      const result = await build({
        ...this.defaultOptions,
        entryPoints: [absolutePath],
        write: false,
        external: ["shortest"]
      });
      const code = result.outputFiles[0].text;
      const tempFile = join(this.cacheDir, "config.mjs");
      writeFileSync(tempFile, code);
      return import(`file://${tempFile}`);
    } catch (error) {
      throw new Error(`Failed to load config from ${absolutePath}: ${error}`);
    }
  }
};

// src/index.ts
var globalConfig = null;
var compiler = new TestCompiler();
if (!global.__shortest__) {
  global.__shortest__ = {
    expect: jestExpect,
    registry: {
      tests: /* @__PURE__ */ new Map(),
      currentFileTests: [],
      beforeAllFns: [],
      afterAllFns: [],
      beforeEachFns: [],
      afterEachFns: []
    }
  };
  global.expect = global.__shortest__.expect;
  dotenv.config({ path: join2(process.cwd(), ".env") });
  dotenv.config({ path: join2(process.cwd(), ".env.local") });
}
function validateConfig(config) {
  const missingFields = [];
  if (config.headless === void 0)
    missingFields.push("headless");
  if (!config.baseUrl)
    missingFields.push("baseUrl");
  if (!config.testDir)
    missingFields.push("testDir");
  if (!config.anthropicKey && !process.env.ANTHROPIC_API_KEY)
    missingFields.push("anthropicKey");
  if (missingFields.length > 0) {
    throw new Error(
      `Missing required fields in shortest.config.ts:
` + missingFields.map((field) => `  - ${field}`).join("\n")
    );
  }
}
async function initialize() {
  if (globalConfig)
    return globalConfig;
  dotenv.config({ path: join2(process.cwd(), ".env") });
  dotenv.config({ path: join2(process.cwd(), ".env.local") });
  const configFiles = [
    "shortest.config.ts",
    "shortest.config.js",
    "shortest.config.mjs"
  ];
  for (const file of configFiles) {
    try {
      const module = await compiler.loadModule(file, process.cwd());
      if (module.default) {
        const config = module.default;
        validateConfig(config);
        globalConfig = {
          ...config,
          anthropicKey: process.env.ANTHROPIC_API_KEY || config.anthropicKey
        };
        return globalConfig;
      }
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Config Error: ${error.message}`);
      }
      continue;
    }
  }
  throw new Error(
    "No config file found. Create shortest.config.ts in your project root.\nRequired fields:\n  - headless: boolean\n  - baseUrl: string\n  - testDir: string | string[]\n  - anthropicKey: string"
  );
}
function getConfig() {
  if (!globalConfig) {
    throw new Error("Config not initialized. Call initialize() first");
  }
  return globalConfig;
}
function createTestChain(name, payload, fn) {
  const test2 = {
    name,
    payload,
    fn,
    expectations: []
  };
  global.__shortest__.registry.tests.set(
    name,
    [...global.__shortest__.registry.tests.get(name) || [], test2]
  );
  global.__shortest__.registry.currentFileTests.push(test2);
  const chain = {
    expect(description, payloadOrFn, fn2) {
      test2.expectations = test2.expectations || [];
      if (typeof payloadOrFn === "function") {
        fn2 = payloadOrFn;
        payloadOrFn = void 0;
      }
      test2.expectations.push({
        description,
        payload: payloadOrFn,
        fn: fn2
      });
      return chain;
    }
  };
  return chain;
}
var test = Object.assign(
  (name, payload, fn) => createTestChain(name, payload, fn),
  {
    beforeAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeAllFns.push(hook);
    },
    afterAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterAllFns.push(hook);
    },
    beforeEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeEachFns.push(hook);
    },
    afterEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterEachFns.push(hook);
    }
  }
);
export {
  getConfig,
  initialize,
  test
};
