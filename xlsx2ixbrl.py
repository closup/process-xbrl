from xlsx2html import xlsx2html
from bs4 import BeautifulSoup
import csv
import pprint
import html
import os
import conf
import argparse
'''''''''''''''''''''''''''''''''
    Utility functions here
'''''''''''''''''''''''''''''''''

# is the cell valid?
def is_valid_cell(s):
    return s is not None and s.string[0] in conf.valid_chars

# get new cell value from old cell value
def process_cell(td, sheet_name):
    id = td['id']
    col = id[len(sheet_name) + 1]
    # calc context
    if col == 'B':
        context = "I20220630_GovernmentalActivities"
    elif col == 'C':
        context = "I20220630_BusinessTypeActivities"
    elif col == 'D':
        context = "I20220630"
    try:
        outstring = td.string
        outstring_int = td.string
        if td.string[0] == "$":
            dollar = "$"
            outstring = td.string[1:]
            outstring_int = td.string[1:]
        else:
            dollar = ""
        if outstring[0] == "-":
            minus = "-"
            sign = ' sign="-"'
            outstring = outstring_int[1:]
        else:
            minus = ""
            sign = ""
        if td.string == "-" or td.string == "$ -":
            minus = ""
            sign = ""
            value = ''
            # value = ' value="0"'  -- Arelle throwing error when I use this
            format = 'ixt:fixed-zero'
            outstring = "-"
        else:
            format = 'ixt:num-dot-decimal'
            value = ""
        row = id[(len(sheet_name)+2):]
        name = names[row]

        cell_id = col + row
        content = f'{dollar}{minus}<ix:nonFraction contextRef="{context}" name="{name}" unitRef="USD" id="{cell_id}" decimals="0" format="{format}"{sign}{value}>' + \
            outstring + '</ix:nonFraction>'
        return content
    except Exception as e:
        return None

'''''''''''''''''''''''''''''''''
    Main code here
'''''''''''''''''''''''''''''''''

# Parse command line first
parser = argparse.ArgumentParser()
parser.add_argument('--i', type=str, metavar="input_file(xlsx)", required=True, help="Input xlsx file name")
parser.add_argument('--o', type=str, metavar="output_file(html)", help="Output html file name")

args = parser.parse_args()

if args.i:
    input_file = args.i
if args.o:
    output_file = args.o
else:
    output_file = input_file.split(".")[0] + ".html"

# Load lookup table between account caption names and taxonomy elements
with open(conf.elements_path) as f:
    next(f)  # Skip the header
    reader = csv.reader(f, skipinitialspace=True)
    elements = dict(reader)

# Use xlsx2html library to Convert Excel Worksheet to html
try:
    xlsx2html(input_file, output_file)
except:
    print("File not eixts or bad format")
    exit(0)

# Because xlsx2html does not right align numeric values, add text-align:right clauses to style attributes for all numbers
# Also use Beautiful Soup to add Inline XBRL ix:nonFraction tags

with open(output_file, 'r') as f:
    html = f.read()

# Get rid of header generated by the xlsx2html library
html_trunc = html.replace(conf.original_header, '')

# Parse html
soup = BeautifulSoup(html_trunc, 'html.parser')
names = {}
sheet_name = None

for td in soup.find_all('td'):
    id = td['id']
    # Get sheet name
    if sheet_name is None:
        sheet_name = td['id'].split("!")[0]
    # Add text-align to all cells
    if is_valid_cell(td):
        td['style'] = td['style'] + ';text-align:right'
    # Calculate Column
    col = id[len(sheet_name) + 1]
    # Process column A
    if col == 'A':
        caption = pprint.pformat((td.contents)).lower()[2:-2]
        try:
            row = id[(len(sheet_name)+2):]
            names[row] = elements[caption]
        except:
            pass

# Process column B, C, D
for td in soup.find_all('td'):
    id = td['id']
    col = id[len(sheet_name) + 1]
    if col in ['B', 'C', 'D'] and is_valid_cell(td):
        content = process_cell(td, sheet_name)
        if content:
            td.string = content

# Replace sheet name if contains space
if " " in sheet_name:
    for td in soup.find_all('td'):
        id = td['id']
        new_id = id.replace(" ", "").replace("!", "_")
        td['id'] = new_id
html_in = soup.prettify("utf-8").decode("utf-8")

# Replace default html header tag with the one required for Inline XBRL
html_out = conf.new_header + '\n' + conf.ix_header.replace("$place_id$", conf.place_id) + '\n'

for line in html_in.splitlines():
    html_out = html_out + line + '\n'

# Add closing tags
html_out = html_out + '</body></html>'

# Replace escaped versions of < and > with the real versions and get rid of the string "Sheet1!" from td ids
html_out = html_out.replace("&lt;", "<")
html_out = html_out.replace("&gt;", ">")
html_out = html_out.replace(f"{sheet_name}!", f"{sheet_name}_")

with open(output_file, 'w') as f:
    f.write(html_out)
    print(f"Successfully converted to {output_file}")

# Arelle functionality requires downloading and installing Arelle
# These commands are intended to validate and display the processed xbrl file in the Javascript viewer
# os.system('"C:\\Program Files\\Arelle\\arellecmdline" --file=D:\\xlsx2ixbrl\\ca_clayton_2022.html --plugins EdgarRenderer')

# This does not work - the idea is to start Arelle's web server and then view the file in Chrome
# os.system('"C:\\Program Files\\Arelle\\arelleCmdLine" --webserver=localhost:5to check 1053')
# os.system('Start chrome /profile-directory="Default" "http://localhost:51053/1/ix.html?doc=ca_clayton_2022.html&xbrl=true?redline=true"')
